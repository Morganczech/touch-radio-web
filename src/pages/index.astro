---
import stationsRaw from "../data/stations.normalized.json";
import BaseLayout from "../layouts/BaseLayout.astro";
import Hero from "../components/Hero.astro";
import Filters from "../components/Filters.astro";
import StationGrid from "../components/StationGrid.astro";
import SelectionSidebar from "../components/SelectionSidebar.astro";
import Footer from "../components/Footer.astro";
import "../styles/station-item.css";

// Filter valid stations first
const allStations = stationsRaw.filter((s: any) => !s.broken);
// No SSR station rendering - strictly client side

// Extract unique values for filters
const uniqueCountries = [
	...new Set(allStations.map((s: any) => s.country).filter(Boolean)),
].sort();
const uniqueGenres = [
	...new Set(allStations.flatMap((s: any) => s.tags || []).filter(Boolean)),
].sort();
const uniqueCodecs = [
	...new Set(allStations.map((s: any) => s.codec).filter(Boolean)),
].sort();
---

<BaseLayout>
	<main>
		<Hero />
		<Filters
			uniqueCountries={uniqueCountries}
			uniqueGenres={uniqueGenres}
			uniqueCodecs={uniqueCodecs}
		/>
		<section class="content-section">
			<div class="section-header">
				<h2>Available Stations</h2>
				<p class="section-subtitle">
					Select stations and export a playlist
				</p>
			</div>
		</section>
		<div class="content-wrapper">
			<div class="main-content">
				<StationGrid />
			</div>
			<SelectionSidebar />
		</div>
		<Footer />
	</main>
</BaseLayout>

<style>
	/* Section Headers */
	.section-header {
		margin-bottom: 3rem;
	}

	.section-header h2 {
		font-size: 1.5rem;
		margin-bottom: 0.25rem;
	}

	.section-subtitle {
		color: var(--muted);
		font-size: 0.95rem;
	}

	/* Original Layout */
	.content-wrapper {
		display: flex;
		gap: 2rem;
		align-items: flex-start;
	}

	.main-content {
		flex: 1;
		min-width: 0; /* Prevents overflow in flex items */
	}

	@media (max-width: 1024px) {
		.content-wrapper {
			flex-direction: column;
		}
	}

	/* Scroll to Top Button */
	.scroll-to-top {
		position: fixed;
		bottom: 2rem;
		right: 2rem;
		width: 48px;
		height: 48px;
		border-radius: 50%;
		background: var(--bg);
		border: 2px solid var(--border);
		color: var(--text);
		font-size: 1.5rem;
		cursor: pointer;
		opacity: 0;
		visibility: hidden;
		transition:
			opacity 0.3s,
			visibility 0.3s,
			transform 0.2s;
		z-index: 998;
		display: flex;
		align-items: center;
		justify-content: center;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
	}

	.scroll-to-top.visible {
		opacity: 1;
		visibility: visible;
	}

	.scroll-to-top:hover {
		transform: translateY(-4px);
		box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
	}

	.scroll-to-top:active {
		transform: translateY(-2px);
	}

	/* Mobile: Position above FAB */
	@media (max-width: 1024px) {
		.scroll-to-top {
			bottom: 9rem; /* Above FAB (FAB is at 2rem, FAB height 64px + gap) */
		}
	}
</style>

<!-- Scroll to Top Button -->
<button id="scroll-to-top" class="scroll-to-top" aria-label="Scroll to top">
	↑
</button>

<style></style>
<script>
	import { appState } from "../scripts/state/appState";
	import { initStations } from "../scripts/stations/stationFilter";
	import {
		initSelection,
		updateUI,
	} from "../scripts/selection/selectionManager";
	import { initDiscoveryBadges } from "../scripts/search/discoveryBadges";
	import { initSearchPlaceholder } from "../scripts/search/searchPlaceholder";
	import { initKeyboardShortcuts } from "../scripts/search/keyboardShortcuts";

	// Initialize State Source of Truth
	// Start empty to avoid bundling massive JSON. Data will be fetched.
	appState.allStations = [];

	document.addEventListener("DOMContentLoaded", async () => {
		initSelection(); // Init selection logic (reading localStorage)
		initDiscoveryBadges();
		initSearchPlaceholder();
		initKeyboardShortcuts();

		// Check if we have shared URL params before fetching, just to be ready
		const { parseShareUrl } = await import(
			"../scripts/utils/sharePlaylist"
		);
		const { showToast } = await import("../scripts/utils/toast");
		const sharedIds = parseShareUrl();

		// Dynamic Fetch of Stations Data (~1MB uncompressed)
		// This prevents the data from being bundled into the initial JS, improving LCP/TBT significantly.
		try {
			const response = await fetch("/stations.json");
			if (!response.ok) throw new Error("Failed to load stations");
			const stationsData = await response.json();

			// Filter broken stations and update state
			appState.allStations = stationsData.filter((s: any) => !s.broken);

			// Now initialize the filter system with loaded data
			initStations(); // filtering happens here

			// Handle Shared Playlist logic after data is loaded
			if (sharedIds && sharedIds.length > 0) {
				// Validate that all IDs exist in our stations
				const validIds = sharedIds.filter((id) =>
					appState.allStations.some((s) => s.id === id),
				);

				if (validIds.length > 0) {
					validIds.forEach((id) => appState.selectedIds.add(id));
					showToast(
						`✓ Loaded ${validIds.length} station${validIds.length !== 1 ? "s" : ""} from shared playlist`,
					);

					// Clean URL
					const url = new URL(window.location.href);
					url.searchParams.delete("playlist");
					window.history.replaceState({}, "", url.toString());
				}
			}

			// Update UI with stations
			updateUI();
		} catch (error) {
			console.error("Error loading stations:", error);
			showToast("Failed to load stations. Please refresh.");
		}

		// Scroll to Top Button
		const scrollToTopBtn = document.getElementById("scroll-to-top");

		if (scrollToTopBtn) {
			// Show/hide button based on scroll position
			window.addEventListener("scroll", () => {
				if (window.scrollY > 300) {
					scrollToTopBtn.classList.add("visible");
				} else {
					scrollToTopBtn.classList.remove("visible");
				}
			});

			// Scroll to top on click
			scrollToTopBtn.addEventListener("click", () => {
				window.scrollTo({
					top: 0,
					behavior: "smooth",
				});
			});
		}
	});
</script>
