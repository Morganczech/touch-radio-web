---
import stations from "../data/stations.normalized.json";
import BaseLayout from "../layouts/BaseLayout.astro";
import StationList from "../components/StationList.astro";

const uniqueCountries = [
	...new Set(stations.map((s) => s.country).filter(Boolean)),
].sort();

const uniqueCodecs = [
	...new Set(stations.map((s) => s.codec).filter(Boolean)),
].sort();

const uniqueGenres = [
	...new Set(stations.flatMap((s) => s.tags || []).filter(Boolean)),
].sort();
---

<BaseLayout>
	<header>
		<h1>Touch Radio</h1>
	</header>
	<main data-stations={JSON.stringify(stations)}>
		<section>
			<h2>Available Stations</h2>
			<label style="display: block; margin-bottom: 1rem;">
				Search stations:
				<input
					type="search"
					id="search-input"
					placeholder="Type station name‚Ä¶"
					autocomplete="off"
					style="margin-left: 0.5rem; padding: 0.25rem;"
				/>
			</label>
			<div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
				<label style="flex: 1;">
					Filter by country:
					<select
						id="country-filter"
						style="width: 100%; margin-top: 0.25rem; padding: 0.25rem;"
					>
						<option value="">All Countries</option>
						{
							uniqueCountries.map((country) => (
								<option value={country}>{country}</option>
							))
						}
					</select>
				</label>
				<label style="flex: 1;">
					Filter by genre:
					<select
						id="genre-filter"
						style="width: 100%; margin-top: 0.25rem; padding: 0.25rem;"
					>
						<option value="">All Genres</option>
						{
							uniqueGenres.map((genre) => (
								<option value={genre}>{genre}</option>
							))
						}
					</select>
				</label>
				<label style="flex: 1;">
					Filter by codec:
					<select
						id="codec-filter"
						style="width: 100%; margin-top: 0.25rem; padding: 0.25rem;"
					>
						<option value="">All Codecs</option>
						{
							uniqueCodecs.map((codec) => (
								<option value={codec}>{codec}</option>
							))
						}
					</select>
				</label>
				<label style="flex: 1;">
					Min bitrate (kbps):
					<input
						type="number"
						id="bitrate-filter"
						placeholder="Min kbps"
						style="width: 100%; margin-top: 0.25rem; padding: 0.25rem;"
					/>
				</label>
				<div
					style="flex: 0 0 auto; display: flex; align-items: flex-end;"
				>
					<button id="clear-filters-btn" style="margin-bottom: 0;"
						>Clear filters</button
					>
				</div>
			</div>
			<p>Select stations and export a playlist</p>
			<p>Selected: <span id="selection-count">0</span></p>
			<button
				id="export-btn"
				disabled
				title="Export selected stations in Touch Radio JSON format"
				>Export JSON</button
			>
			<button
				id="export-m3u-btn"
				disabled
				title="Export playlist in M3U format">Export M3U</button
			>
			<button
				id="export-m3u8-btn"
				disabled
				title="Export playlist in UTF-8 encoded M3U8 format"
				>Export M3U8 (UTF-8)</button
			>
			<button
				id="export-pls-btn"
				disabled
				title="Export playlist in PLS format">Export PLS</button
			>
			<div class="content-wrapper">
				<div class="main-content">
					<StationList stations={stations} />
				</div>
				<aside class="selection-panel">
					<h3>My Selection</h3>
					<div id="selection-list" class="selection-list">
						<p class="empty-state">No stations selected</p>
					</div>
				</aside>
			</div>
		</section>
	</main>

	<style>
		.content-wrapper {
			display: flex;
			gap: 2rem;
			align-items: flex-start;
		}

		.main-content {
			flex: 1;
			min-width: 0; /* Prevents overflow in flex items */
		}

		.selection-panel {
			width: 300px;
			flex-shrink: 0;
			background: var(--bg);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 1rem;
			position: sticky;
			top: 1rem;
			max-height: calc(100vh - 2rem);
			overflow-y: auto;
		}

		.selection-list {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
			margin-top: 1rem;
		}

		.empty-state {
			color: var(--muted);
			font-style: italic;
			text-align: center;
			padding: 1rem 0;
		}

		@media (max-width: 1024px) {
			.content-wrapper {
				flex-direction: column;
			}

			.selection-panel {
				width: 100%;
				position: static;
				max-height: 500px;
			}
		}

		/* Helper styles for dynamically created elements */
		:global(.selected-item) {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 0.5rem;
			background: rgba(0, 0, 0, 0.02);
			border-radius: 6px;
			border: 1px solid var(--border);
		}

		:global([data-theme="dark"] .selected-item) {
			background: rgba(255, 255, 255, 0.05);
		}

		:global(.selected-item-info) {
			display: flex;
			flex-direction: column;
			gap: 0.1rem;
			overflow: hidden;
		}

		:global(.selected-item-name) {
			font-weight: 600;
			font-size: 0.9rem;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		:global(.selected-item-meta) {
			font-size: 0.75rem;
			color: var(--muted);
		}

		:global(.remove-btn) {
			background: none;
			border: none;
			cursor: pointer;
			color: #e74c3c;
			padding: 0.25rem;
			font-size: 1.1rem;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: transform 0.2s;
		}

		:global(.remove-btn:hover) {
			transform: scale(1.1);
		}
	</style>
	<script>
		// Client-side state management for station selection
		document.addEventListener("DOMContentLoaded", () => {
			const selectedIds = new Set();
			const exportBtn = document.getElementById("export-btn");
			const mainElement = document.querySelector("main");
			// Parse stations data from data attribute safely
			const allStations =
				mainElement && mainElement.dataset.stations
					? JSON.parse(mainElement.dataset.stations)
					: [];

			const checkboxes = document.querySelectorAll(
				'input[type="checkbox"][data-id]',
			);

			checkboxes.forEach((checkbox) => {
				checkbox.addEventListener("change", (event) => {
					const target = event.target as HTMLInputElement;
					const id = target.dataset.id;

					if (id) {
						if (target.checked) {
							selectedIds.add(id);
						} else {
							selectedIds.delete(id);
						}
						updateUI();
					}
				});
			});

			// Initial UI update
			const countSpan = document.getElementById("selection-count");
			const buttons = [
				document.getElementById("export-btn"),
				document.getElementById("export-m3u-btn"),
				document.getElementById("export-m3u8-btn"),
				document.getElementById("export-pls-btn"),
			];

			// Helper to get flag from country code (duplicated logic from StationItem for client-side use)
			// Ideally this would be shared code, but keeping strict vanilla JS in this file as per constraints
			const COUNTRY_CODES: Record<string, string> = {
				Germany: "DE",
				Hungary: "HU",
				"The United States Of America": "US",
				USA: "US",
				"The United Kingdom Of Great Britain And Northern Ireland":
					"GB",
				UK: "GB",
				"Great Britain": "GB",
				"Islamic Republic Of Iran": "IR",
				Iran: "IR",
				Czechia: "CZ",
				"Czech Republic": "CZ",
				France: "FR",
				Poland: "PL",
				"The Russian Federation": "RU",
				Russia: "RU",
				Ukraine: "UA",
				Tunisia: "TN",
				"The Netherlands": "NL",
				Netherlands: "NL",
				Spain: "ES",
				Italy: "IT",
				Greece: "GR",
				Switzerland: "CH",
				Austria: "AT",
				Belgium: "BE",
			};

			function getFlag(countryName: string) {
				const code = COUNTRY_CODES[countryName];
				if (!code || code.length !== 2) return "üåç";
				const offset = 127397;
				const chars = [...code.toUpperCase()].map(
					(c) => c.charCodeAt(0) + offset,
				);
				return String.fromCodePoint(...chars);
			}

			function updateUI() {
				const count = selectedIds.size;
				if (countSpan) {
					countSpan.textContent = count.toString();
				}

				// Update helper buttons state
				const isDisabled = count === 0;
				buttons.forEach((btn) => {
					if (btn) {
						if (isDisabled) {
							btn.setAttribute("disabled", "true");
						} else {
							btn.removeAttribute("disabled");
						}
					}
				});

				// Update Selection Panel
				const selectionList = document.getElementById("selection-list");
				if (selectionList) {
					selectionList.innerHTML = "";

					if (count === 0) {
						selectionList.innerHTML =
							'<p class="empty-state">No stations selected</p>';
					} else {
						const selectedStations = allStations.filter((s: any) =>
							selectedIds.has(s.id),
						);
						selectedStations.forEach((station: any) => {
							const item = document.createElement("div");
							item.className = "selected-item";

							const flag = getFlag(station.country);

							item.innerHTML = `
								<div class="selected-item-info">
									<div class="selected-item-name">${flag} ${station.name}</div>
									<div class="selected-item-meta">${station.codec} ‚Ä¢ ${station.bitrate}kbps</div>
								</div>
								<button class="remove-btn" data-remove-id="${station.id}" title="Remove from selection">‚ù§Ô∏è</button>
							`;
							selectionList.appendChild(item);
						});

						// Add event listeners for remove buttons
						selectionList
							.querySelectorAll(".remove-btn")
							.forEach((btn) => {
								btn.addEventListener("click", (e) => {
									const target =
										e.currentTarget as HTMLButtonElement;
									const idToRemove = target.dataset.removeId;
									if (idToRemove) {
										// Uncheck the checkbox
										const checkbox = document.querySelector(
											`input[data-id="${idToRemove}"]`,
										) as HTMLInputElement;
										if (checkbox) {
											checkbox.checked = false;
											checkbox.dispatchEvent(
												new Event("change"),
											);
										}
									}
								});
							});
					}
				}
			}

			if (exportBtn) {
				exportBtn.addEventListener("click", () => {
					if (selectedIds.size === 0) {
						alert("No stations selected.");
						return;
					}

					const selectedStations = allStations.filter(
						(station: any) => selectedIds.has(station.id),
					);
					const jsonString = JSON.stringify(
						selectedStations,
						null,
						2,
					);
					downloadFile(
						jsonString,
						"selected_stations.json",
						"application/json",
					);
				});
			}

			const exportM3uBtn = document.getElementById("export-m3u-btn");
			if (exportM3uBtn) {
				exportM3uBtn.addEventListener("click", () => {
					if (selectedIds.size === 0) {
						alert("No stations selected.");
						return;
					}

					const selectedStations = allStations.filter(
						(station: any) => selectedIds.has(station.id),
					);

					let m3uContent = "#EXTM3U\n";
					selectedStations.forEach((station: any) => {
						m3uContent += `#EXTINF:-1,${station.name}\n${station.streamUrl}\n`;
					});

					downloadFile(
						m3uContent,
						"selected_stations.m3u",
						"text/plain",
					);
				});
			}

			const exportM3u8Btn = document.getElementById("export-m3u8-btn");
			if (exportM3u8Btn) {
				exportM3u8Btn.addEventListener("click", () => {
					if (selectedIds.size === 0) {
						alert("No stations selected.");
						return;
					}

					const selectedStations = allStations.filter(
						(station: any) => selectedIds.has(station.id),
					);

					let m3uContent = "#EXTM3U\n";
					selectedStations.forEach((station: any) => {
						m3uContent += `#EXTINF:-1,${station.name}\n${station.streamUrl}\n`;
					});

					downloadFile(
						m3uContent,
						"selected_stations.m3u8",
						"text/plain;charset=utf-8",
					);
				});
			}

			const exportPlsBtn = document.getElementById("export-pls-btn");
			if (exportPlsBtn) {
				exportPlsBtn.addEventListener("click", () => {
					if (selectedIds.size === 0) {
						alert("No stations selected.");
						return;
					}

					const selectedStations = allStations.filter(
						(station: any) => selectedIds.has(station.id),
					);

					let plsContent = "[playlist]\n";
					plsContent += `NumberOfEntries=${selectedStations.length}\n`;

					selectedStations.forEach((station: any, index: number) => {
						const i = index + 1;
						plsContent += `File${i}=${station.streamUrl}\n`;
						plsContent += `Title${i}=${station.name}\n`;
						plsContent += `Length${i}=-1\n`;
					});

					plsContent += "Version=2\n";

					downloadFile(
						plsContent,
						"selected_stations.pls",
						"text/plain",
					);
				});
			}

			function downloadFile(
				content: string,
				filename: string,
				type: string,
			) {
				const blob = new Blob([content], { type: type });
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
			}

			// Favicon handling
			const stationImages = document.querySelectorAll(
				"img[data-favicon]",
			) as NodeListOf<HTMLImageElement>;

			stationImages.forEach((img) => {
				const faviconUrl = img.dataset.favicon;
				if (faviconUrl) {
					const tempImg = new Image();
					tempImg.onload = () => {
						img.src = faviconUrl;
					};
					// Handle error silently, placeholder remains
					tempImg.onerror = () => {};
					tempImg.src = faviconUrl;
				}
			});

			// Search and Filter functionality
			const searchInput = document.getElementById(
				"search-input",
			) as HTMLInputElement;
			const countryFilter = document.getElementById(
				"country-filter",
			) as HTMLSelectElement;
			const genreFilter = document.getElementById(
				"genre-filter",
			) as HTMLSelectElement;
			const codecFilter = document.getElementById(
				"codec-filter",
			) as HTMLSelectElement;
			const bitrateFilter = document.getElementById(
				"bitrate-filter",
			) as HTMLInputElement;
			const stationItems = document.querySelectorAll(
				"li[data-name]",
			) as NodeListOf<HTMLLIElement>;

			function filterStations() {
				const query = searchInput
					? searchInput.value.trim().toLowerCase()
					: "";
				const selectedCountry = countryFilter
					? countryFilter.value
					: "";
				const selectedGenre = genreFilter ? genreFilter.value : "";
				const selectedCodec = codecFilter ? codecFilter.value : "";
				const minBitrate =
					bitrateFilter && bitrateFilter.value
						? parseInt(bitrateFilter.value)
						: 0;

				stationItems.forEach((item) => {
					const name = item.dataset.name || "";
					const country = item.dataset.country || "";
					const tags = (item.dataset.tags || "").split(",");
					const codec = item.dataset.codec || "";
					const bitrate = item.dataset.bitrate
						? parseInt(item.dataset.bitrate)
						: 0;

					const matchesName = name.includes(query);
					const matchesCountry =
						selectedCountry === "" || country === selectedCountry;
					const matchesGenre =
						selectedGenre === "" || tags.includes(selectedGenre);
					const matchesCodec =
						selectedCodec === "" || codec === selectedCodec;
					const matchesBitrate = bitrate >= minBitrate;

					item.style.display =
						matchesName &&
						matchesCountry &&
						matchesGenre &&
						matchesCodec &&
						matchesBitrate
							? ""
							: "none";
				});
			}

			if (searchInput) {
				searchInput.addEventListener("input", filterStations);
			}

			if (countryFilter) {
				countryFilter.addEventListener("change", filterStations);
			}

			if (genreFilter) {
				genreFilter.addEventListener("change", filterStations);
			}

			if (codecFilter) {
				codecFilter.addEventListener("change", filterStations);
			}

			if (bitrateFilter) {
				bitrateFilter.addEventListener("input", filterStations);
			}

			const clearFiltersBtn =
				document.getElementById("clear-filters-btn");
			if (clearFiltersBtn) {
				clearFiltersBtn.addEventListener("click", () => {
					if (searchInput) searchInput.value = "";
					if (countryFilter) countryFilter.value = "";
					if (genreFilter) genreFilter.value = "";
					if (codecFilter) codecFilter.value = "";
					if (bitrateFilter) bitrateFilter.value = "";
					filterStations();
				});
			}

			// Inline Audio Preview Logic
			const audioPlayer = new Audio();
			let currentPlayingButton: HTMLButtonElement | null = null;

			function stopPlayback() {
				audioPlayer.pause();
				audioPlayer.src = "";
				if (currentPlayingButton) {
					const icon =
						currentPlayingButton.querySelector(".play-icon");
					if (icon) icon.textContent = "‚ñ∂Ô∏è";
					// Find the parent station item/card to remove active class
					const stationItem =
						currentPlayingButton.closest(".station-item");
					if (stationItem) {
						stationItem.classList.remove("is-playing");
					}
					currentPlayingButton = null;
				}
			}

			// Delegate event listener for play buttons since they might be dynamically updated (though strictly here they are static, but good practice)
			// Actually, StationList is static so we can attach listeners directly or delegate from main.
			// Let's attach to all .play-btn elements.
			const playButtons = document.querySelectorAll(".play-btn");
			playButtons.forEach((btn) => {
				btn.addEventListener("click", (e) => {
					e.preventDefault();
					e.stopPropagation(); // Prevent card click (selection)

					const button = e.currentTarget as HTMLButtonElement;
					const streamUrl = button.dataset.stream;
					const icon = button.querySelector(".play-icon");

					if (currentPlayingButton === button) {
						// Toggle Pause
						if (audioPlayer.paused) {
							audioPlayer.play().catch((err) => {
								console.error("Playback failed", err);
								stopPlayback();
							});
							if (icon) icon.textContent = "‚è∏Ô∏è";
							const stationItem = button.closest(".station-item");
							if (stationItem)
								stationItem.classList.add("is-playing");
						} else {
							stopPlayback();
						}
					} else {
						// Stop previous
						stopPlayback();

						// Play new
						if (streamUrl) {
							currentPlayingButton = button;
							audioPlayer.src = streamUrl;
							audioPlayer.play().catch((err) => {
								console.error("Playback failed", err);
								stopPlayback();
								// alert("Playback failed. Stream might be offline or incompatible."); // Optional: silent fail is often better for previews
							});

							if (icon) icon.textContent = "‚è∏Ô∏è";
							const stationItem = button.closest(".station-item");
							if (stationItem)
								stationItem.classList.add("is-playing");
						}
					}
				});
			});

			// Handle audio errors/end
			audioPlayer.addEventListener("error", () => {
				stopPlayback();
			});
			audioPlayer.addEventListener("ended", () => {
				stopPlayback();
			});
		});
	</script>
</BaseLayout>
